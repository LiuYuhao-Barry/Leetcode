# 每日一题 2021.3.7-2021.3.14周结



## 131. 分割回文串

深度优先搜索+动态规划预处理后的剪枝

通过这题复习了DFS的写法。DFS以及回溯剪枝的题目几乎没怎么做过，之后要加强练习。



- 动态规划预处理：

  - 自己首先想到的写法：

    1. 将对角线元素初始化为1；

    2. 对对角线元素右面的元素进行初始化；

    3. 从最下面开始，从左往右进行初始化，直至填满整个数组。

  - 这个过程可以简化为：

    - 把所有元素初始化为1，这样节省了步骤1；
    - 对于对角线元素右面一个位置的元素，其代表的是长度为2的子串是否为回文串，其值只与$s[i]$是否等于$s[j]$有关，与其左下角元素的值无关。所以初始化的时候，将数组的下三角区域初始化为1，之后直接用`s[i]==s[j] && s[i+1][j-1]==1​`来表示其值即可，这样可以把步骤2合并到步骤3里，代码更加简洁。

$$
dp[i][j]=\begin{cases}
1,&s[i]=s[j] \ \&\& \ dp[i+1][j-1]=1\\
0,&others
\end{cases}
$$



## 132. 分割回文串 II

重点在于理解预处理之后，如何用$O(N^2)$的时间复杂度求得最小分割次数。

### 方法一（第一次想到的方法）：

- 用一个二维数组$dp$存储原字符串$s$的各个子串是否为回文子串，其中第$i$行的第$j$个元素的值为0/1分别代表$s[i,...,j]$这个字串不是/是回文子串。这个预处理的过程可以通过动态规划的方法在$O(N^2)$的时间复杂度内完成，存储结果需要一个$N*N$的二维数组。状态转移方程如下：

$$
dp[i][j]=\begin{cases}
1,&s[i]=s[j] \ \&\& \ dp[i+1][j-1]=1\\
0,&others
\end{cases}
$$

- 用另外一个二维数组$f$来保存原字符串$s$的各个子串需要的最小分割次数，其中$f[i][j]$表示$s[i,...,j]$这个字串需要的最小分割次数。这样有如下的状态转移方程：

$$
f[i][j] = \begin{cases}
1, &dp[i][j]=1 \\
min\{dp[i][j+k]+dp[i+k][j]\},&0\leq k\leq j-i
\end{cases}
$$

- 这样的方法时间复杂度为$O(N^3)$，空间复杂度为$O(N^2)$



### 方法二：

上面的方法不能满足题目所给出的数据规模大小要求。思考如何可以进行优化？

- 让$f[i]$表示子串$s[0,...,i]$的最小分割次数，并按照如下的状态转移方程计算$f$各个位置的值，最终$f$的最后一个元素即为最后结果。


$$
f[i]=\begin{cases}
0,&dp[0][i]==1 \\
\\
\min\limits_{0\leq j<i}\{f[j]\}+1, &dp[j+1][i] = 1
\end{cases}
$$

- 状态转移方程的含义：
  - 如果$dp[0][i]=1$，说明$s[0,...,i]$是一个回文子串，不需要分割即可满足要求，所以对应位置的值为0；
  - 除了上述情况外，对于所有满足$0\leq j<i$，并且子串$s[j+1,...,i]$为回文串（即$dp[j+1][i]=1$）的位置$j$，子串$s[0,...,i]$只需要在子串$s[0,...,j]$的基础上额外进行一次分割即可。所以在所有符合条件的$j$中，使得$f[j]$值加上额外的分割次数1即是$f[i]$的值。
- 这种方法的时间复杂度为$O(N^2)$，空间复杂度为$O(N^2)$
- 思考：本方法相比于方法一，在哪里减少了重复的计算？
  - 在方法一中，$f[i][j]$虽然正确保存了子串$s[i,...,j]$的最小分割次数，但是当计算$f[i][j]$时，考虑了满足$0\leq k\leq j-i$的所有的$k$，而对于范围内有很大一部分的$k$对应的子串$s[k+1,...,j]$并不是回文子串，不是回文子串的这部分额外计算出所有范围下$f[i][j]$的值进行验证。如果只考虑是回文子串的情况，其实已经覆盖了这一部分的情况。所以只需要维护$s[0,...i]$的最小分割次数即可，不需要维护任意字符到任意字符的最小分割次数。
  - 换句话说，让子串$s[0,...,i]$满足要求的最后一次分割后面的子串一定是一个回文串，所以只需要考虑使子串$s[j+1,...,i]$为回文串的那些$j$即可得出正确结果。



## 1047. 删除字符串中的所有重复项

栈的简单应用，使用栈可以大幅简化操作。

注意：<string\>和<vector\>可以直接作为栈使用，因为这两个容器提供了`push_back()`、`pop_back()`、`back()`函数，分别对应<stack\>中的`push()`、`pop()`和`top()`，字符串或向量的末尾相当于栈顶



## 224. 基本计算器

计算器是栈的重要应用场景之一，难点在于合适进行出栈入栈操作。

本题难点在于如何处理括号以及括号所带来的计算优先级问题。



## 227. 基本计算器 II

本体没有括号，但是有乘法和除法，同样涉及到了优先级问题。本题和上一题都比较考验写代码技巧，否则代码会十分冗长，而且难以编写。

其中一个技巧是，对于第一个数字，是为其前面有一个"+"号。



## 331. 验证二叉树的前序序列化

利用二叉树的性质进行计数即可。

也要理解题解一中的“槽位”思想，以及用出栈入栈的方法表示“槽位”的占用情况，之后做其他树的题目时可能会涉及到类似的操作。



## 705. 设计哈希集合

自己之前没有实现过哈希表，正好这次补补课。

这道题可以通过开一个大数组求解，但是面试时如果问到类似的问题，开一个大数组话肯定不会是面试官想听到的结果。所以正确思路时自己实现一个可以解决冲突的哈希表。

求key的常用方法（散列函数）：**除留取余法**，平方取中法，根据数据特点设计哈希函数

解决冲突的常用方法：**拉链法**，线性探测法，二次探测法

要掌握除留取余法+拉链法的哈希表的实现。



## 706. 设计哈希映射

和上一题类似，只是多了更新map的过程

通过这一题熟悉了<pair\>的用法。